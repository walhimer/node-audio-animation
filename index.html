<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>DNA AV Node — p5 + Soundscape + Shared Transport</title>
  <style>
    html,body{margin:0;padding:0;background:#06060a;overflow:hidden;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial}
    #hud{
      position:fixed;left:14px;top:14px;z-index:50;
      background:rgba(0,0,0,0.50);border:1px solid rgba(255,255,255,0.12);
      border-radius:14px;padding:10px 12px;backdrop-filter: blur(10px);
      color:rgba(255,255,255,0.84);font-size:12px;line-height:1.25;max-width:760px;
      user-select:none
    }
    #row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    button{
      background:rgba(255,255,255,0.10);color:#fff;border:1px solid rgba(255,255,255,0.18);
      border-radius:12px;padding:9px 11px;cursor:pointer
    }
    button:hover{background:rgba(255,255,255,0.14)}
    .pill{
      display:inline-block;border:1px solid rgba(255,255,255,0.14);border-radius:999px;
      padding:4px 8px;background:rgba(255,255,255,0.06);font-size:11px;letter-spacing:0.04em
    }
    #toast{
      display:inline-block;margin-left:6px;padding:4px 8px;border-radius:10px;
      border:1px solid rgba(255,255,255,0.14);background:rgba(255,255,255,0.06);
      font-size:11px;letter-spacing:0.06em;text-transform:uppercase;
      opacity:0;transform:translateY(-2px);transition:opacity 180ms ease,transform 180ms ease
    }
    #toast.on{opacity:1;transform:translateY(0)}
    #small{color:rgba(255,255,255,0.60);font-size:11px;margin-top:6px;max-width:760px}
    #sliders{display:flex;gap:10px;align-items:center;flex-wrap:wrap;margin-top:8px}
    .s{
      display:flex;gap:8px;align-items:center;
      padding:6px 8px;border-radius:12px;border:1px solid rgba(255,255,255,0.12);
      background:rgba(255,255,255,0.04)
    }
    .s label{font-size:11px;color:rgba(255,255,255,0.68);min-width:54px}
    .s input[type="range"]{width:160px}
    .s .v{font-variant-numeric:tabular-nums;font-size:11px;color:rgba(255,255,255,0.80);min-width:36px;text-align:right}

    #layout{position:fixed;inset:0;display:flex}
    #canvasWrap{flex:1;position:relative}
    #editorWrap{
      width:min(46vw, 720px);
      background:rgba(6,6,10,0.96);
      border-left:1px solid rgba(255,255,255,0.10);
      display:none;flex-direction:column;
    }
    #editorTop{
      padding:10px 12px;border-bottom:1px solid rgba(255,255,255,0.10);
      display:flex;gap:8px;align-items:center;flex-wrap:wrap
    }
    #code{
      flex:1;resize:none;border:0;outline:none;
      padding:12px 12px 18px 12px;
      font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;
      font-size:12px;line-height:1.4;
      color:rgba(255,255,255,0.90);
      background:transparent;
      white-space:pre;
    }
    #hint{color:rgba(255,255,255,0.55);font-size:11px}
  </style>
</head>

<body>
  <div id="layout">
    <div id="canvasWrap"></div>

    <div id="editorWrap">
      <div id="editorTop">
        <button id="applyBtn">APPLY CODE</button>
        <button id="saveBtn">SAVE</button>
        <button id="loadBtn">LOAD</button>
        <button id="clearBtn">CLEAR</button>
        <span id="hint">Paste a p5 sketch body. Use <b>DNA_AV</b> for time/audio sync.</span>
      </div>
      <textarea id="code" spellcheck="false"></textarea>
    </div>
  </div>

  <div id="hud">
    <div id="row">
      <button id="audioBtn">START AUDIO</button>
      <button id="toggleCodeBtn">CODE</button>
      <button id="resyncBtn">RESYNC</button>
      <span class="pill" id="nodePill">node: —</span>
      <span class="pill" id="dnaPill">dna: —</span>
      <span class="pill" id="timePill">bar: — beat: —</span>
      <span class="pill" id="energyPill">energy: —</span>
      <span class="pill" id="audioPill">audio: off</span>
      <span id="toast"></span>
    </div>

    <div id="sliders">
      <div class="s"><label>density</label><input id="den" type="range" min="0" max="1" step="0.001"><div class="v" id="denV">—</div></div>
      <div class="s"><label>drift</label><input id="dri" type="range" min="0" max="1" step="0.001"><div class="v" id="driV">—</div></div>
      <div class="s"><label>spread</label><input id="spr" type="range" min="0" max="1" step="0.001"><div class="v" id="sprV">—</div></div>
      <div class="s"><label>tension</label><input id="ten" type="range" min="0" max="1" step="0.001"><div class="v" id="tenV">—</div></div>
    </div>

    <div id="small">
      Single-file node: put <b>index.html</b> next to <b>dna.json</b>. Click <b>START AUDIO</b> once (browser requirement). Your visuals and audio share the same <b>transport</b> clock.
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/p5@1.9.4/lib/p5.min.js"></script>

  <script>
  // ============================================================
  // DNA AV NODE — single-file HTML + p5 + WebAudio (no Python)
  // ============================================================

  // ---------- tiny helpers
  function clamp01(x){ return Math.max(0, Math.min(1, x)); }
  function lerp(a,b,t){ return a + (b-a)*t; }
  function smoothstep(x){ x=clamp01(x); return x*x*(3-2*x); }
  function easePow(x,p){ x=clamp01(x); return Math.pow(x,p); }

  function hash32(str){
    let h = 2166136261 >>> 0;
    for (let i=0;i<str.length;i++){
      h ^= str.charCodeAt(i);
      h = Math.imul(h, 16777619);
    }
    return h >>> 0;
  }

  function mulberry32(seed){
    let a = seed >>> 0;
    return function(){
      a |= 0; a = (a + 0x6D2B79F5) | 0;
      let t = Math.imul(a ^ (a >>> 15), 1 | a);
      t ^= t + Math.imul(t ^ (t >>> 7), 61 | t);
      return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
    }
  }

  function toast(msg){
    const el = document.getElementById("toast");
    el.textContent = msg;
    el.classList.add("on");
    clearTimeout(toast._t);
    toast._t = setTimeout(()=>el.classList.remove("on"), 900);
  }

  // ---------- identity
  const url = new URL(location.href);
  const nodeId = url.searchParams.get("nodeId") || "screen01";
  document.getElementById("nodePill").textContent = `node: ${nodeId}`;

  // ---------- storage keys
  const TRANSPORT_KEY = "dna_transport_t0_unix_ms_v2";
  const STATE_KEY     = "dna_av_state_v2";
  const CODE_KEY      = "dna_av_code_v2";

  // ---------- DNA
  let dna = null;
  async function loadDNA(){
    const res = await fetch("dna.json", { cache: "no-store" });
    if (!res.ok) throw new Error("Could not load dna.json next to index.html");
    return await res.json();
  }

  // ---------- shared transport
  const transport = {
    bpm: 70,
    beatsPerBar: 4,
    t0_unix_ms: null,
    tSec: 0,
    beatDur: 60/70,
    barDur: 4*(60/70),
    beatFloat: 0,
    beatIndex: 0,
    barIndex: 0,
    beatInBar: 0
  };

  function setTransportFromDNA(){
    transport.bpm = dna.transport?.bpm ?? 70;
    transport.beatsPerBar = dna.transport?.beatsPerBar ?? 4;
    transport.beatDur = 60 / transport.bpm;
    transport.barDur = transport.beatsPerBar * transport.beatDur;
  }

  function ensureT0(){
    const dnaT0 = dna.transport?.t0_unix_ms;
    if (typeof dnaT0 === "number" && isFinite(dnaT0)){
      transport.t0_unix_ms = dnaT0;
      localStorage.setItem(TRANSPORT_KEY, String(Math.floor(dnaT0)));
      return;
    }
    const stored = Number(localStorage.getItem(TRANSPORT_KEY));
    if (stored && isFinite(stored)){
      transport.t0_unix_ms = stored;
      return;
    }
    const now = Date.now();
    transport.t0_unix_ms = now;
    localStorage.setItem(TRANSPORT_KEY, String(now));
  }

  function resyncT0(){
    const now = Date.now();
    transport.t0_unix_ms = now;
    localStorage.setItem(TRANSPORT_KEY, String(now));
    toast("resynced");
  }

  function updateTransport(){
    const now = Date.now();
    transport.tSec = (now - transport.t0_unix_ms) / 1000;
    transport.beatFloat = transport.tSec / transport.beatDur;
    transport.beatIndex = Math.floor(transport.beatFloat);
    transport.barIndex  = Math.floor(transport.tSec / transport.barDur);
    transport.beatInBar = transport.beatIndex % transport.beatsPerBar;
  }

  // ---------- macro “crescendo” envelope (shared form)
  const macro = { energy: 0, phase: 0 };

  function updateMacro(dt){
    const m = dna.macro || {};
    const cycleSec = m.cycleSec ?? 140;
    const attack   = m.attack ?? 0.55;
    const hold     = m.hold ?? 0.08;
    const release  = m.release ?? 0.37;
    const shape    = m.shape ?? 2.2;

    const ph = (transport.tSec / cycleSec) % 1;
    macro.phase = ph;

    let e = 0;
    if (ph < attack){
      const x = ph / attack;
      e = smoothstep(easePow(x, shape));
    } else if (ph < attack + hold){
      e = 1;
    } else {
      const x = (ph - (attack + hold)) / release;
      e = 1 - smoothstep(easePow(x, 1.6));
    }
    macro.energy = lerp(macro.energy, e, 1 - Math.exp(-dt * 1.2));
  }

  // ---------- controls (UI + saved state)
  const current = { density: 0.38, drift: 0.22, spread: 0.62, tension: 0.46 };

  const den = document.getElementById("den");
  const dri = document.getElementById("dri");
  const spr = document.getElementById("spr");
  const ten = document.getElementById("ten");

  function setSlider(el, val){
    el.value = String(clamp01(val));
  }
  function readSliders(){
    current.density = Number(den.value);
    current.drift   = Number(dri.value);
    current.spread  = Number(spr.value);
    current.tension = Number(ten.value);
    document.getElementById("denV").textContent = current.density.toFixed(2);
    document.getElementById("driV").textContent = current.drift.toFixed(2);
    document.getElementById("sprV").textContent = current.spread.toFixed(2);
    document.getElementById("tenV").textContent = current.tension.toFixed(2);
  }

  function applyDefaultsFromDNA(){
    const d = dna.controls?.defaults || {};
    current.density = d.density ?? current.density;
    current.drift   = d.drift   ?? current.drift;
    current.spread  = d.spread  ?? current.spread;
    current.tension = d.tension ?? current.tension;

    setSlider(den, current.density);
    setSlider(dri, current.drift);
    setSlider(spr, current.spread);
    setSlider(ten, current.tension);
    readSliders();
  }

  // ---------- Save / Load / Clear (REAL)
  function saveState(){
    const state = {
      density: current.density,
      drift: current.drift,
      spread: current.spread,
      tension: current.tension
    };
    localStorage.setItem(STATE_KEY, JSON.stringify(state));
    localStorage.setItem(CODE_KEY, document.getElementById("code").value);
    toast("saved");
  }

  function loadState(){
    const raw = localStorage.getItem(STATE_KEY);
    if (raw){
      try{
        const s = JSON.parse(raw);
        if (typeof s.density === "number") current.density = clamp01(s.density);
        if (typeof s.drift   === "number") current.drift   = clamp01(s.drift);
        if (typeof s.spread  === "number") current.spread  = clamp01(s.spread);
        if (typeof s.tension === "number") current.tension = clamp01(s.tension);
      }catch(e){}
    }
    setSlider(den, current.density);
    setSlider(dri, current.drift);
    setSlider(spr, current.spread);
    setSlider(ten, current.tension);
    readSliders();

    const code = localStorage.getItem(CODE_KEY);
    if (typeof code === "string" && code.length) document.getElementById("code").value = code;

    toast("loaded");
  }

  function clearState(){
    localStorage.removeItem(STATE_KEY);
    localStorage.removeItem(CODE_KEY);
    toast("cleared");
  }

  document.getElementById("saveBtn").onclick  = saveState;
  document.getElementById("loadBtn").onclick  = loadState;
  document.getElementById("clearBtn").onclick = clearState;

  den.oninput = dri.oninput = spr.oninput = ten.oninput = () => { readSliders(); };

  // ---------- audio analysis (shared)
  let analysis = { rms: 0, centroid: 0 };

  // ---------- WebAudio soundscape (Flint-adjacent: crescendo + tails, not “music”)
  let audio = null;

  function makeSoftClipCurve(amount){
    const n = 2048;
    const curve = new Float32Array(n);
    for (let i=0;i<n;i++){
      const x = (i/(n-1))*2 - 1;
      const a = 4*(1.0 - amount);
      curve[i] = x / (1 + a*Math.abs(x));
    }
    return curve;
  }

  function makeAudio(nodeRand){
    const ctx = new (window.AudioContext || window.webkitAudioContext)();

    const mix = ctx.createGain();
    const shaper = ctx.createWaveShaper();
    shaper.curve = makeSoftClipCurve(dna.audio?.master?.softClip ?? 0.92);
    shaper.oversample = "4x";

    const analyser = ctx.createAnalyser();
    analyser.fftSize = 2048;
    const freqData = new Uint8Array(analyser.frequencyBinCount);
    const timeData = new Uint8Array(analyser.fftSize);

    const master = ctx.createGain();
    master.gain.value = 0.0;

    mix.connect(shaper);
    shaper.connect(analyser);
    analyser.connect(master);
    master.connect(ctx.destination);

    // noise buffer
    const noiseBuf = ctx.createBuffer(1, ctx.sampleRate*2, ctx.sampleRate);
    const ch = noiseBuf.getChannelData(0);
    for (let i=0;i<ch.length;i++) ch[i] = (Math.random()*2 - 1);

    // Bed (filtered noise)
    const bed = ctx.createBufferSource();
    bed.buffer = noiseBuf; bed.loop = true;
    const bedHP = ctx.createBiquadFilter(); bedHP.type = "highpass";
    const bedLP = ctx.createBiquadFilter(); bedLP.type = "lowpass";
    const bedGain = ctx.createGain(); bedGain.gain.value = 0.0;
    bed.connect(bedHP); bedHP.connect(bedLP); bedLP.connect(bedGain);

    // Drone (2 osc)
    const o1 = ctx.createOscillator();
    const o2 = ctx.createOscillator();
    o1.type = "sine"; o2.type = "triangle";
    const root = dna.audio?.drone?.rootHz ?? 43.65;
    const det = (nodeRand()*2 - 1) * 0.25;
    o1.frequency.value = root + det;
    o2.frequency.value = root*2 + det*1.6;
    const droneLP = ctx.createBiquadFilter(); droneLP.type = "lowpass";
    const droneGain = ctx.createGain(); droneGain.gain.value = 0.0;
    o1.connect(droneLP); o2.connect(droneLP); droneLP.connect(droneGain);

    // Shimmer (bandpassed noise)
    const shimmerOut = ctx.createGain(); shimmerOut.gain.value = 0.0;
    const shimmerSrc = ctx.createBufferSource();
    shimmerSrc.buffer = noiseBuf; shimmerSrc.loop = true;
    const shimmerHP = ctx.createBiquadFilter(); shimmerHP.type = "highpass";
    shimmerSrc.connect(shimmerHP);

    const bands = dna.audio?.shimmer?.bands ?? 4;
    const shimmerFilters = [];
    for (let i=0;i<bands;i++){
      const bp = ctx.createBiquadFilter();
      bp.type = "bandpass";
      shimmerHP.connect(bp);
      bp.connect(shimmerOut);
      shimmerFilters.push(bp);
    }

    // Space (feedback delay + damping)
    const pre = ctx.createGain();
    const delay = ctx.createDelay(3.0);
    const fb = ctx.createGain();
    const damp = ctx.createBiquadFilter(); damp.type = "lowpass";
    const wet = ctx.createGain();
    const dry = ctx.createGain();

    pre.connect(dry);
    pre.connect(delay);
    delay.connect(damp);
    damp.connect(wet);
    damp.connect(fb);
    fb.connect(delay);

    dry.connect(mix);
    wet.connect(mix);

    // route
    bedGain.connect(pre);
    droneGain.connect(pre);
    shimmerOut.connect(pre);

    // start continuous sources
    bed.start();
    shimmerSrc.start();
    o1.start(); o2.start();

    function setSmooth(param, value, time=0.12){
      const now = ctx.currentTime;
      param.cancelScheduledValues(now);
      param.setTargetAtTime(value, now, time);
    }

    // grains (beat-scheduled micro events)
    let lastBeat = -1;

    function spawnGrain(atTimeSec){
      const now = ctx.currentTime;
      const t = Math.max(now, atTimeSec);

      const src = ctx.createBufferSource();
      src.buffer = noiseBuf;

      const g = ctx.createGain();
      g.gain.value = 0.0;

      const bp = ctx.createBiquadFilter();
      bp.type = "bandpass";

      const ten = current.tension;
      const M = macro.energy;

      const bpMin = dna.audio?.grains?.bpHz?.[0] ?? 240;
      const bpMax = dna.audio?.grains?.bpHz?.[1] ?? 5200;
      const qMin  = dna.audio?.grains?.q?.[0] ?? 8;
      const qMax  = dna.audio?.grains?.q?.[1] ?? 26;

      const u = nodeRand();
      const f = bpMin + (bpMax-bpMin) * clamp01(0.25 + 0.60*ten + 0.35*M + (u-0.5)*0.25);
      bp.frequency.value = Math.max(120, f);
      bp.Q.value = qMin + (qMax-qMin) * clamp01(0.25 + 0.70*ten);

      const durMin = dna.audio?.grains?.durSec?.[0] ?? 0.035;
      const durMax = dna.audio?.grains?.durSec?.[1] ?? 0.22;
      const dur = durMin + (durMax-durMin) * (0.2 + 0.8*nodeRand());

      const gMin = dna.audio?.grains?.gain?.[0] ?? 0.0006;
      const gMax = dna.audio?.grains?.gain?.[1] ?? 0.006;
      const a = (gMin + (gMax-gMin) * current.density) * (0.10 + 0.90*M);

      src.connect(bp);
      bp.connect(g);
      g.connect(pre);

      g.gain.setValueAtTime(0.0, t);
      g.gain.linearRampToValueAtTime(a, t + 0.010);
      g.gain.exponentialRampToValueAtTime(0.00001, t + dur);

      src.start(t);
      src.stop(t + dur + 0.02);
    }

    function getAnalysis(){
      analyser.getByteFrequencyData(freqData);
      analyser.getByteTimeDomainData(timeData);

      let sum = 0;
      for (let i=0;i<timeData.length;i++){
        const v = (timeData[i]-128)/128;
        sum += v*v;
      }
      const rms = Math.sqrt(sum / timeData.length);

      let wsum=0, vsum=0;
      for (let i=0;i<freqData.length;i++){
        const v = freqData[i]/255;
        vsum += v;
        wsum += v*i;
      }
      const centroid = vsum > 1e-6 ? (wsum/vsum)/freqData.length : 0;

      return { rms, centroid };
    }

    function start(){
      const g = dna.audio?.master?.gain ?? 0.85;
      setSmooth(master.gain, g, 0.25);
    }

    function update(dt){
      const M = macro.energy;
      const dens = current.density;
      const dr   = current.drift;
      const sp   = current.spread;
      const ten  = current.tension;

      // Bed
      const bedHpMin = dna.audio?.bed?.hpHz?.[0] ?? 35;
      const bedHpMax = dna.audio?.bed?.hpHz?.[1] ?? 120;
      const bedLpMin = dna.audio?.bed?.lpHz?.[0] ?? 350;
      const bedLpMax = dna.audio?.bed?.lpHz?.[1] ?? 2400;
      const bedGMin  = dna.audio?.bed?.gain?.[0] ?? 0.004;
      const bedGMax  = dna.audio?.bed?.gain?.[1] ?? 0.040;

      setSmooth(bedHP.frequency, bedHpMin + (bedHpMax-bedHpMin)*(0.3 + 0.7*(1-sp)), 0.20);
      setSmooth(bedLP.frequency, bedLpMin + (bedLpMax-bedLpMin)*(0.25 + 0.75*ten), 0.20);
      setSmooth(bedGain.gain, (bedGMin + (bedGMax-bedGMin)*dens) * (0.25 + 0.75*M), 0.18);

      // Drone
      const droneGMin = dna.audio?.drone?.gain?.[0] ?? 0.010;
      const droneGMax = dna.audio?.drone?.gain?.[1] ?? 0.090;
      const lpMin = dna.audio?.drone?.lpHz?.[0] ?? 180;
      const lpMax = dna.audio?.drone?.lpHz?.[1] ?? 1500;
      const qMin  = dna.audio?.drone?.q?.[0] ?? 0.9;
      const qMax  = dna.audio?.drone?.q?.[1] ?? 7.0;

      setSmooth(droneGain.gain, (droneGMin + (droneGMax-droneGMin)*dens) * (0.20 + 0.80*M), 0.22);
      setSmooth(droneLP.frequency, lpMin + (lpMax-lpMin)*ten, 0.22);
      setSmooth(droneLP.Q, qMin + (qMax-qMin)*ten, 0.22);

      // Shimmer
      const shFmin = dna.audio?.shimmer?.freqHz?.[0] ?? 380;
      const shFmax = dna.audio?.shimmer?.freqHz?.[1] ?? 5200;
      const shQmin = dna.audio?.shimmer?.q?.[0] ?? 4.0;
      const shQmax = dna.audio?.shimmer?.q?.[1] ?? 22.0;
      const shGmin = dna.audio?.shimmer?.gain?.[0] ?? 0.0005;
      const shGmax = dna.audio?.shimmer?.gain?.[1] ?? 0.050;

      const shGain = (shGmin + (shGmax-shGmin)*dens) * (0.15 + 1.10*ten) * (0.15 + 0.85*M);
      setSmooth(shimmerOut.gain, shGain, 0.30);

      const t = transport.tSec * (0.05 + dr*0.22);
      for (let i=0;i<shimmerFilters.length;i++){
        const bp = shimmerFilters[i];
        const bandU = (i+1)/(shimmerFilters.length+1);
        const wob = Math.sin(t*0.7 + bandU*5.0 + (nodeRand()*2-1)*0.2)*0.5 + 0.5;
        const f = shFmin + (shFmax-shFmin) * clamp01(0.15 + 0.70*ten + 0.25*wob);
        const q = shQmin + (shQmax-shQmin) * clamp01(0.25 + 0.75*ten);
        setSmooth(bp.frequency, f, 0.60);
        setSmooth(bp.Q, q, 0.60);
      }

      // Space tail-hold
      const wetMin  = dna.audio?.space?.wet?.[0] ?? 0.10;
      const wetMax  = dna.audio?.space?.wet?.[1] ?? 0.90;
      const dMin    = dna.audio?.space?.delaySec?.[0] ?? 0.14;
      const dMax    = dna.audio?.space?.delaySec?.[1] ?? 0.80;
      const fbMin   = dna.audio?.space?.fb?.[0] ?? 0.12;
      const fbMax   = dna.audio?.space?.fb?.[1] ?? 0.90;
      const dampMin = dna.audio?.space?.dampHz?.[0] ?? 700;
      const dampMax = dna.audio?.space?.dampHz?.[1] ?? 3100;

      const tailHold = Math.max(sp, 0.65) * (0.65 + 0.35*(1 - M));
      setSmooth(wet.gain, wetMin + (wetMax-wetMin)*tailHold, 0.32);
      setSmooth(dry.gain, 0.92 - 0.55*tailHold, 0.32);
      setSmooth(delay.delayTime, dMin + (dMax-dMin)*tailHold, 0.34);
      setSmooth(fb.gain, fbMin + (fbMax-fbMin)*tailHold, 0.36);
      setSmooth(damp.frequency, dampMin + (dampMax-dampMin)*(1.0 - tailHold), 0.36);

      // Beat-scheduled grains
      const beatNow = transport.beatIndex;
      if (beatNow !== lastBeat){
        lastBeat = beatNow;
        const grainsPerBeat = (0.15 + 1.10*dens) * (0.12 + 0.88*M);
        const n = Math.floor(grainsPerBeat + nodeRand());
        for (let i=0;i<n;i++){
          const within = nodeRand() * transport.beatDur;
          const atAudio = ctx.currentTime + 0.03 + within;
          spawnGrain(atAudio);
        }
      }
    }

    return { ctx, start, update, getAnalysis };
  }

  // ---------- beat triggers for visuals
  const trig = { lastBeat:-1, pulse:0, pulse2:0 };
  function updateTriggers(dt){
    if (transport.beatIndex !== trig.lastBeat){
      trig.lastBeat = transport.beatIndex;
      trig.pulse = 1.0;
      if (transport.beatInBar === 0) trig.pulse2 = 1.0;
    }
    trig.pulse  = Math.max(0, trig.pulse  - dt*3.2);
    trig.pulse2 = Math.max(0, trig.pulse2 - dt*1.6);
  }

  // ---------- expose sync API to user code
  window.DNA_AV = {
    get dna(){ return dna; },
    transport,
    macro,
    trig,
    current,
    analysis
  };

  // ---------- editor + user sketch injection (p5 instance mode)
  let p5Instance = null;

  const DEFAULT_USER_CODE = `
// Your code runs inside: function userDraw(p, DNA_AV) { ... }
// - p is the p5 instance
// - DNA_AV.transport.tSec is shared time
// - DNA_AV.macro.energy is crescendo (0..1)
// - DNA_AV.analysis.rms / centroid are audio-driven
// - DNA_AV.trig.pulse / pulse2 are beat pulses

function userSetup(p, DNA_AV){
  // optional
}

function userDraw(p, DNA_AV){
  const { transport, macro, analysis, trig, dna } = DNA_AV;

  const rms = analysis.rms || 0;
  const cen = analysis.centroid || 0;

  // DNA ranges (fallbacks)
  const bg = dna?.visual?.bg || {};
  const field = dna?.visual?.field || {};
  const motion = dna?.visual?.motion || {};

  const hueMin = (bg.hue && bg.hue[0]) ?? 220;
  const hueMax = (bg.hue && bg.hue[1]) ?? 330;
  const satMin = (bg.sat && bg.sat[0]) ?? 12;
  const satMax = (bg.sat && bg.sat[1]) ?? 65;
  const briMin = (bg.bri && bg.bri[0]) ?? 2;
  const briMax = (bg.bri && bg.bri[1]) ?? 14;

  const bgHue = (hueMin + (hueMax-hueMin) * clamp01(0.15 + 0.65*cen + 0.20*macro.energy)) % 360;
  const bgSat = satMin + (satMax-satMin) * clamp01(0.15 + 0.55*macro.energy);
  const bgBri = briMin + (briMax-briMin) * clamp01(0.10 + 0.35*macro.energy);

  p.colorMode(p.HSB, 360, 100, 100, 1);
  p.background(bgHue, bgSat, bgBri, 1);

  const cMin = (field.count && field.count[0]) ?? 120;
  const cMax = (field.count && field.count[1]) ?? 1400;
  const aMin = (field.alpha && field.alpha[0]) ?? 0.010;
  const aMax = (field.alpha && field.alpha[1]) ?? 0.040;
  const sMin = (field.size && field.size[0]) ?? 1.0;
  const sMax = (field.size && field.size[1]) ?? 10.0;

  const densityFromEnergy = clamp01(0.20 + 0.80*macro.energy);
  const pulseBoost = clamp01(0.20*trig.pulse + 0.35*trig.pulse2);
  const rmsBoost = clamp01(rms * 2.6);

  const N = Math.floor(lerp(cMin, cMax, clamp01(densityFromEnergy + pulseBoost*0.5 + rmsBoost*0.35)));
  const alpha = lerp(aMin, aMax, clamp01(0.30 + 0.55*macro.energy + 0.35*rmsBoost));
  const sizeBase = lerp(sMin, sMax, clamp01(0.20 + 0.65*macro.energy + 0.25*cen));

  const nsMin = (motion.noiseScale && motion.noiseScale[0]) ?? 0.0010;
  const nsMax = (motion.noiseScale && motion.noiseScale[1]) ?? 0.0045;
  const trMin = (motion.timeRate && motion.timeRate[0]) ?? 0.000035;
  const trMax = (motion.timeRate && motion.timeRate[1]) ?? 0.000085;

  const noiseScale = lerp(nsMin, nsMax, clamp01(0.20 + 0.80*cen));
  const timeRate = lerp(trMin, trMax, clamp01(0.15 + 0.60*macro.energy));

  const beatPhase = transport.beatFloat % 1; // 0..1
  const t = transport.tSec * timeRate + beatPhase * 0.08;

  p.blendMode(p.ADD);

  for (let i=0;i<N;i++){
    const x0 = (i * 101) % p.width;
    const y0 = (i * 61) % p.height;

    const nx = p.noise(x0*noiseScale, y0*noiseScale, t);
    const ny = p.noise(x0*noiseScale + 130, y0*noiseScale + 70, t);

    const ang = (nx*2 - 1) * Math.PI * (0.55 + 2.2*cen);
    const r = (10 + 55*macro.energy) * (0.55 + 1.8*ny);

    const x = x0 + Math.cos(ang) * r;
    const y = y0 + Math.sin(ang) * r;

    const hue = (bgHue + 60*nx + 40*cen) % 360;
    const sat = 10 + 60*clamp01(0.20 + 0.80*macro.energy);
    const bri = 6 + 34*clamp01(0.15 + 0.85*macro.energy) + 18*pulseBoost;

    const sz = sizeBase * (0.35 + 1.2*nx) * (0.80 + 1.6*pulseBoost);

    p.fill(hue, sat, bri, alpha);
    p.circle(x, y, sz);
  }

  // subtle "reverb tail" vignette (energy drop = more visible)
  p.blendMode(p.BLEND);
  const tail = clamp01(0.10 + 0.65*(1 - macro.energy));
  p.noStroke();
  p.fill(bgHue, bgSat, bgBri * 0.8, 0.12 * tail);
  p.rect(0,0,p.width,p.height);
}
`.trim();

  function buildUserFuncs(source){
    // we evaluate into a tiny scope so user can define userSetup / userDraw
    const wrapped = `
      "use strict";
      let userSetup = null;
      let userDraw = null;
      ${source}
      return { userSetup, userDraw };
    `;
    return (new Function("clamp01","lerp","smoothstep","easePow", wrapped))(clamp01, lerp, smoothstep, easePow);
  }

  function startSketch(){
    if (p5Instance) { p5Instance.remove(); p5Instance = null; }

    const code = document.getElementById("code").value;
    let user = null;

    try{
      user = buildUserFuncs(code);
      if (typeof user.userDraw !== "function") throw new Error("Define function userDraw(p, DNA_AV)");
    }catch(e){
      toast("code error");
      console.error(e);
      return;
    }

    p5Instance = new p5((p)=>{
      p.setup = () => {
        const canvas = p.createCanvas(window.innerWidth, window.innerHeight);
        canvas.parent("canvasWrap");
        p.pixelDensity(2);
        p.frameRate(60);
        p.noStroke();

        if (typeof user.userSetup === "function"){
          try{ user.userSetup(p, window.DNA_AV); }catch(e){ console.error(e); }
        }
      };

      p.windowResized = () => p.resizeCanvas(window.innerWidth, window.innerHeight);

      p.draw = () => {
        if (!dna) return;

        const dt = Math.min(0.05, p.deltaTime/1000);

        updateTransport();
        updateMacro(dt);
        updateTriggers(dt);

        // audio update + analysis
        if (audio){
          audio.update(dt);
          analysis = audio.getAnalysis();
          window.DNA_AV.analysis = analysis;
        }else{
          analysis = { rms:0, centroid:0 };
          window.DNA_AV.analysis = analysis;
        }

        // HUD
        document.getElementById("timePill").textContent   = `bar: ${transport.barIndex} beat: ${transport.beatInBar+1}/${transport.beatsPerBar}`;
        document.getElementById("energyPill").textContent = `energy: ${macro.energy.toFixed(2)}`;

        // user visuals
        try{
          user.userDraw(p, window.DNA_AV);
        }catch(e){
          console.error(e);
        }
      };
    });
  }

  // ---------- UI wiring
  document.getElementById("resyncBtn").onclick = () => resyncT0();

  const editorWrap = document.getElementById("editorWrap");
  let editorOn = false;
  document.getElementById("toggleCodeBtn").onclick = () => {
    editorOn = !editorOn;
    editorWrap.style.display = editorOn ? "flex" : "none";
    toast(editorOn ? "code on" : "canvas");
  };

  document.getElementById("applyBtn").onclick = () => {
    startSketch();
    toast("applied");
  };

  document.getElementById("audioBtn").onclick = async () => {
    if (!audio){
      const nodeSeed = (dna.seed >>> 0) ^ hash32(nodeId);
      const nodeRand = mulberry32(nodeSeed);
      audio = makeAudio(nodeRand);
    }
    if (audio.ctx.state !== "running") await audio.ctx.resume();
    audio.start();
    document.getElementById("audioPill").textContent = "audio: on";
    toast("audio on");
  };

  // ---------- boot
  (async function boot(){
    dna = await loadDNA();
    window.DNA_AV.dna = dna;

    document.getElementById("dnaPill").textContent = `dna: ${dna.family || "unnamed"} | seed ${dna.seed}`;

    setTransportFromDNA();
    ensureT0();

    // defaults
    applyDefaultsFromDNA();

    // load saved state/code if present
    document.getElementById("code").value = localStorage.getItem(CODE_KEY) || DEFAULT_USER_CODE;
    loadState(); // safe even if empty; will re-set sliders/code if saved

    // start visuals immediately (audio waits for click)
    startSketch();

    toast("ready");
  })().catch((e)=>{
    console.error(e);
    toast("dna load fail");
  });
  </script>
</body>
</html>


